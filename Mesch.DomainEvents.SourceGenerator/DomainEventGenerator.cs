using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;

namespace Mesch.DomainEvents;

[Generator]
public class DomainEventGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
        {
            return;
        }

        var compilation = context.Compilation;

        // Process both classes and records
        var allCandidates = new List<TypeDeclarationSyntax>();
        allCandidates.AddRange(receiver.CandidateClasses.Cast<TypeDeclarationSyntax>());
        allCandidates.AddRange(receiver.CandidateRecords.Cast<TypeDeclarationSyntax>());

        foreach (var typeDeclaration in allCandidates)
        {
            GenerateEventsForType(compilation, typeDeclaration, context);
        }
    }

    private static void GenerateEventsForType(Compilation compilation, TypeDeclarationSyntax typeDeclaration, GeneratorExecutionContext context)
    {
        var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
        var declaredSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

        if (declaredSymbol is not INamedTypeSymbol typeSymbol)
        {
            return;
        }

        // Look for GenerateDomainEventsAttribute
        var generateDomainEventsAttribute = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "GenerateDomainEventsAttribute" ||
                                a.AttributeClass?.ToDisplayString() == "Mesch.DomainEvents.GenerateDomainEventsAttribute");

        if (generateDomainEventsAttribute == null)
        {
            return;
        }

        var config = ExtractConfiguration(generateDomainEventsAttribute, typeSymbol);

        // Find all methods with DomainEventAttribute
        var allMethodsWithEvents = typeSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.GetAttributes().Any(a => a.AttributeClass?.Name == "DomainEventAttribute" ||
                                                  a.AttributeClass?.ToDisplayString() == "Mesch.DomainEvents.DomainEventAttribute"));

        var methodsWithEvents = new List<IMethodSymbol>(allMethodsWithEvents);

        if (methodsWithEvents.Count == 0)
        {
            return;
        }

        // Generate events
        var eventsCode = EventRecordGenerator.GenerateEventRecords(methodsWithEvents, config, typeSymbol);
        var helperCode = config.GenerateHelperClass ? HelperClassGenerator.GenerateHelperClass(methodsWithEvents, config, typeSymbol) : "";

        var fullCode = $@"// <auto-generated />
#nullable enable

using System;
using Mesch.DomainEvents;

namespace {config.EventNamespace}
{{
{eventsCode}

{helperCode}
}}";

        var fileName = $"{typeSymbol.Name}.Events.g.cs";
        context.AddSource(fileName, fullCode);
    }

    private static EventGenerationConfig ExtractConfiguration(AttributeData attribute, INamedTypeSymbol typeSymbol)
    {
        var config = new EventGenerationConfig
        {
            EventNamespace = typeSymbol.ContainingNamespace.ToDisplayString() + ".Events",
            EventSuffix = "Event",
            GenerateHelperClass = true,
            HelperClassName = typeSymbol.Name + "Events"
        };

        foreach (var namedArgument in attribute.NamedArguments)
        {
            switch (namedArgument.Key)
            {
                case "EventNamespace":
                    if (namedArgument.Value.Value is string eventNamespace)
                    {
                        config.EventNamespace = eventNamespace;
                    }
                    break;
                case "EventSuffix":
                    if (namedArgument.Value.Value is string eventSuffix)
                    {
                        config.EventSuffix = eventSuffix;
                    }
                    break;
                case "GenerateHelperClass":
                    if (namedArgument.Value.Value is bool generateHelperClass)
                    {
                        config.GenerateHelperClass = generateHelperClass;
                    }
                    break;
                case "HelperClassName":
                    if (namedArgument.Value.Value is string helperClassName)
                    {
                        config.HelperClassName = helperClassName;
                    }
                    break;
            }
        }

        return config;
    }
}

internal class SyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();
    public List<RecordDeclarationSyntax> CandidateRecords { get; } = new List<RecordDeclarationSyntax>();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // Look for both classes AND records with attributes
        if (syntaxNode is ClassDeclarationSyntax classDeclaration && classDeclaration.AttributeLists.Count > 0)
        {
            CandidateClasses.Add(classDeclaration);
        }
        else if (syntaxNode is RecordDeclarationSyntax recordDeclaration && recordDeclaration.AttributeLists.Count > 0)
        {
            CandidateRecords.Add(recordDeclaration);
        }
    }
}